Microsoft.Maps.Pushpin.prototype.Metadata = null;
Microsoft.Maps.Polyline.prototype.Metadata = null;
Microsoft.Maps.Polygon.prototype.Metadata = null;
Microsoft.Maps.EntityCollection.prototype.Metadata = null;
var GeoJSONModule = function () {
    var o = null
        , n = []
        , m = {
            pushpinOptions: null,
            polylineOptions: null,
            polygonOptions: null
        };
    function a(q) {
        if (o != null) {
            var p = e(q);
            var r;
            if (n != null && n.length > 0) {
                r = Microsoft.Maps.LocationRect.fromLocations(n);
            } else {
                r = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(0, 0), 360, 180);
            }
            o(p, r)
        }
    }
    function e(r) {
        var q = null;
        switch (r.type) {
            case "FeatureCollection":
                q = b(r);
                break;
            case "Feature":
                q = l(r);
                break;
            case "Point":
                var p = i(r);
                q = f(p);
                if (r.properties) {
                    q.Metadata = r.properties;
                }
                break;
            case "LineString":
                q = c(r);
                break;
            case "Polygon":
                q = j(r);
                break;
            case "MultiPoint":
                q = new Microsoft.Maps.EntityCollection();
                $(h(r)).each(function (t, s) {
                    q.push(f(s));
                });
                break;
            case "MultiLineString":
                q = new Microsoft.Maps.EntityCollection();
                $(g(r)).each(function (t, s) {
                    q.push(s);
                });
                break;
            case "MultiPolygon":
                q = new Microsoft.Maps.EntityCollection();
                $(d(r)).each(function (t, s) {
                    q.push(s);
                });
                break;
            case "GeometryCollection":
                q = k(r);
                break;
            default:
        }
        return q;
    }
    function i(q) {
        var r = new Microsoft.Maps.Location(q.coordinates[1], q.coordinates[0]);
        n.push(r);
        return r
    }
    function c(q) {
        var p = new Microsoft.Maps.Polyline(h(q), m.polylineOptions);
        if (q.properties) {
            p.Metadata = q.properties;
        }
        return p
    }
    function j(q) {
        var r = [];
        $(q.coordinates).each(function (t, s) {
            r.push(h({
                coordinates: s
            }))
        });
        var p = new Microsoft.Maps.Polygon(r, m.polygonOptions);
        if (q.properties) {
            p.Metadata = q.properties
        }
        return p
    }
    function h(p) {
        var q = [];
        $(p.coordinates).each(function (s, r) {
            q.push(i({
                coordinates: r
            }))
        });
        if (p.properties) {
            q.Metadata = p.properties
        }
        return q
    }
    function g(q) {
        var p = [];
        $(q.coordinates).each(function (s, r) {
            p.push(c({
                coordinates: r
            }))
        });
        if (q.properties) {
            p.Metadata = q.properties
        }
        return p
    }
    function d(p) {
        var q = [];
        $(p.coordinates).each(function (s, r) {
            q.push(j({
                coordinates: r
            }))
        });
        if (p.properties) {
            q.Metadata = p.properties
        }
        return q
    }
    function k(q) {
        var p = new Microsoft.Maps.EntityCollection();
        $(q.geometries).each(function (t, s) {
            var r = l({
                geometry: s
            });
            if (r) {
                p.push(r)
            }
        });
        if (q.properties) {
            p.Metadata = q.properties
        }
        return p
    }
    function l(r) {
        var q;
        var s = r.geometry;
        switch (s.type) {
            case "Point":
                var p = i(s);
                q = f(p);
                if (s.properties) {
                    q.Metadata = s.properties
                }
                break;
            case "LineString":
                q = c(s);
                break;
            case "Polygon":
                q = j(s);
                break;
            case "MultiPoint":
                q = new Microsoft.Maps.EntityCollection();
                $(h(s)).each(function (u, t) {
                    q.push(f(t))
                });
                break;
            case "MultiLineString":
                q = new Microsoft.Maps.EntityCollection();
                $(g(s)).each(function (u, t) {
                    q.push(t)
                });
                break;
            case "MultiPolygon":
                q = new Microsoft.Maps.EntityCollection();
                $(d(s)).each(function (u, t) {
                    q.push(t)
                });
                break;
            default:
        }
        if (r.properties) {
            q.Metadata = r.properties
        }
        return q
    }
    function b(q) {
        var p = new Microsoft.Maps.EntityCollection();
        $(q.features).each(function (s, r) {
            p.push(l(r))
        });
        return p
    }
    function f(p) {
        return new Microsoft.Maps.Pushpin(p, m.pushpinOptions)
    }
    this.ImportGeoJSON = function (q, r, p) {
        o = r;
        if (p != null) {
            for (attrname in p) {
                m[attrname] = p[attrname];
            }
        }
        $.getJSON(q, function (s) {
            a(s);
        });
    };
};
(function () {
    var a = new Microsoft.Maps.Polygon(new Microsoft.Maps.Location(0, 0));
    if (!a.getRings) {
        Microsoft.Maps.loadModule("Microsoft.Maps.AdvancedShapes", {
            callback: function () {
                Microsoft.Maps.moduleLoaded("GeoJSONModule");
            }
        })
    } else {
        Microsoft.Maps.moduleLoaded("GeoJSONModule");
    }
}
)();